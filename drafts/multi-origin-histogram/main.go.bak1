package main

import (
	// Standard Library
	"database/sql"
	"errors"
	"fmt"
	"log"
	"strings"
	// Third-Party Packages
	_ "github.com/mattn/go-sqlite3" // SQLite driver
)

// -------------------------------------------------------------------
// 1) Data Structures and Constants
// -------------------------------------------------------------------

type CityInput struct {
	Name       string
	PriceLimit float64
}

// LogicalOperator represents a logical operator (AND, OR)
type LogicalOperator string

const (
	AndOperator LogicalOperator = "AND"
	OrOperator  LogicalOperator = "OR"
)

// Expression is an interface that can be a single city or a logical combo.
type Expression interface{}

// CityCondition represents a condition for a single city
type CityCondition struct {
	City CityInput
}

// LogicalExpression represents a logical combination of sub-expressions
type LogicalExpression struct {
	Operator LogicalOperator
	Left     Expression
	Right    Expression
}

// For demonstration, a minimal flight struct to hold query results
type Flight struct {
	DestinationCity   string
	Price             float64
	AccommodationPppn float64
	// Add other fields as needed
}

// -------------------------------------------------------------------
// 2) Parse the User Inputs into a Logical Expression (AND/OR structure)
// -------------------------------------------------------------------

func parseLogicalExpression(cities []string, logicalOperators []string, maxPrices []float64) (Expression, error) {
	// Basic checks
	if len(cities) == 0 {
		return nil, errors.New("no cities provided")
	}
	if len(cities) != len(maxPrices) {
		return nil, errors.New("mismatched city vs. price arrays")
	}
	// For n cities, you generally have (n-1) operators
	if len(cities) != len(logicalOperators)+1 {
		return nil, errors.New("mismatched city vs. operator arrays")
	}

	// Base case: single city
	if len(cities) == 1 {
		return &CityCondition{City: CityInput{Name: cities[0], PriceLimit: maxPrices[0]}}, nil
	}

	// Start with the first city
	var expr Expression = &CityCondition{City: CityInput{Name: cities[0], PriceLimit: maxPrices[0]}}

	// Build up the expression tree
	for i := 1; i < len(cities); i++ {
		op := LogicalOperator(logicalOperators[i-1])
		nextCityCond := &CityCondition{
			City: CityInput{Name: cities[i], PriceLimit: maxPrices[i]},
		}

		expr = &LogicalExpression{
			Operator: op,
			Left:     expr,
			Right:    nextCityCond,
		}
	}
	return expr, nil
}

// -------------------------------------------------------------------
// 3) Build the Subquery for the DestinationSet (via the Expression tree)
// -------------------------------------------------------------------

func BuildFlightOriginsSubquery(expr Expression) (string, []interface{}) {
	switch e := expr.(type) {
	case *CityCondition:
		// Single city
		subquery := `
            SELECT
                f.destination_city_name,
                f.destination_country
            FROM flight f
            WHERE f.origin_city_name = ?
              AND f.price_next_week < ?
            GROUP BY f.destination_city_name, f.destination_country
        `
		args := []interface{}{e.City.Name, e.City.PriceLimit}
		return subquery, args

	case *LogicalExpression:
		leftSubquery, leftArgs := BuildFlightOriginsSubquery(e.Left)
		rightSubquery, rightArgs := BuildFlightOriginsSubquery(e.Right)

		var operator string
		if e.Operator == AndOperator {
			operator = "INTERSECT"
		} else {
			operator = "UNION"
		}

		combined := fmt.Sprintf(`%s
%s
%s`, leftSubquery, operator, rightSubquery)

		return combined, append(leftArgs, rightArgs...)

	default:
		panic("Unknown expression type")
	}
}

// -------------------------------------------------------------------
// 4) Define the Base Query (after the DestinationSet CTE)
// -------------------------------------------------------------------

const baseQuery = `
    SELECT 
        ds.destination_city_name,
        MIN(f.price_next_week) AS price_city1,
        a.booking_pppn,
        MIN(f.duration_in_minutes) AS duration_mins
    FROM DestinationSet ds
    JOIN flight f 
      ON ds.destination_city_name = f.destination_city_name 
         AND ds.destination_country = f.destination_country
    LEFT JOIN accommodation a
      ON a.city = ds.destination_city_name 
         AND a.country = ds.destination_country
    -- Potentially other joins: weather w, location l, etc.
    WHERE 
      f.price_next_week < ?
      AND f.origin_city_name IN 
`

// -------------------------------------------------------------------
// 5) Build the Final Query String + Arguments
// -------------------------------------------------------------------

func BuildMainQuery(
	expr Expression,
	maxAccommodationPrice float64, // your "slider" for accommodation
	originCities []string,
	orderClause string,
) (string, []interface{}) {

	// 1) Start with the "WITH DestinationSet" portion
	var queryBuilder strings.Builder
	var args []interface{}

	queryBuilder.WriteString("WITH DestinationSet AS (\n")

	// 2) Build the subquery from the logical expression
	subquery, subArgs := BuildFlightOriginsSubquery(expr)
	queryBuilder.WriteString(subquery)
	queryBuilder.WriteString("\n)")

	args = append(args, subArgs...)

	// 3) Append the base query
	queryBuilder.WriteString(baseQuery)

	// 4) If no origins, you can return empty or handle differently
	if len(originCities) == 0 {
		return "", nil
	}

	// We'll add placeholders for the originCities
	placeholders := make([]string, len(originCities))
	for i := range originCities {
		placeholders[i] = "?"
	}
	inClause := "(" + strings.Join(placeholders, ", ") + ")"
	queryBuilder.WriteString(inClause)

	// Then add the accommodation constraint:
	queryBuilder.WriteString(`
      AND a.booking_pppn IS NOT NULL
      AND a.booking_pppn <= ?
    GROUP BY ds.destination_city_name
    `)
	// (Add more GROUP BY columns if needed for your actual tables)

	// 5) Add the order clause
	if orderClause != "" {
		queryBuilder.WriteString(" ")
		queryBuilder.WriteString(orderClause)
	}
	queryBuilder.WriteString(";")

	// 6) Build the args in the order the placeholders appear
	// First for f.price_next_week < ?
	// Here, you might be using a global flight price limit.
	// Or you might set it high (like 999999) if you only want the subquery to matter.
	globalMaxFlightPrice := 2000.0
	args = append(args, globalMaxFlightPrice)

	// Then the origin cities
	for _, city := range originCities {
		args = append(args, city)
	}

	// Finally the accommodation slider
	args = append(args, maxAccommodationPrice)

	return queryBuilder.String(), args
}

// -------------------------------------------------------------------
// 6) Sorting / ORDER BY Clause
// -------------------------------------------------------------------

var orderByClauses = map[string]string{
	"cheapest_fnaf":         "ORDER BY fnf.price_fnaf ASC",
	"most_expensive_fnaf":   "ORDER BY fnf.price_fnaf DESC",
	"best_weather":          "ORDER BY l.avg_wpi DESC",
	"worst_weather":         "ORDER BY l.avg_wpi ASC",
	"cheapest_hotel":        "ORDER BY a.booking_pppn ASC",
	"most_expensive_hotel":  "ORDER BY a.booking_pppn DESC",
	"shortest_flight":       "ORDER BY f.duration_hour_dot_mins ASC",
	"longest_flight":        "ORDER BY f.duration_hour_dot_mins DESC",
	"cheapest_flight":       "ORDER BY f.price_this_week ASC",
	"most_expensive_flight": "ORDER BY f.price_this_week DESC",
}

func determineOrderClause(sortOption string) string {
	if clause, found := orderByClauses[sortOption]; found {
		return clause
	}
	// Default
	return "ORDER BY f.price_next_week ASC"
}

// -------------------------------------------------------------------
// 7) Example Function To Tie It All Together and Execute
// -------------------------------------------------------------------

func QueryFlights(
	db *sql.DB,
	// Suppose the user picks these 2 origin inputs:
	origins []string, // e.g. ["NYC", "LAX"]
	operators []string, // e.g. ["AND"]
	maxFlightPrices []float64, // e.g. [300.0, 600.0]
	// The user sets a slider for global accommodation:
	maxAccommodation float64, // e.g. 200.0
	sortOption string, // e.g. "cheapest_fnaf"
) ([]Flight, error) {

	// 1) Build the logical expression from user input
	expr, err := parseLogicalExpression(origins, operators, maxFlightPrices)
	if err != nil {
		return nil, fmt.Errorf("parse expression: %w", err)
	}

	// 2) Determine the ORDER BY clause from the user sort choice
	orderClause := determineOrderClause(sortOption)

	// 3) Build the main query + arguments
	query, args := BuildMainQuery(expr, maxAccommodation, origins, orderClause)
	if query == "" {
		return nil, errors.New("no query built (possibly no origins)")
	}

	// For debugging/logging:
	log.Printf("Generated Query:\n%s\nArgs: %v\n", query, args)

	// 4) Execute the query
	rows, err := db.Query(query, args...)
	if err != nil {
		return nil, fmt.Errorf("db query failed: %w", err)
	}
	defer rows.Close()

	// 5) Read results
	var results []Flight
	for rows.Next() {
		var f Flight
		// Example fields in the SELECT:
		// ds.destination_city_name, MIN(f.price_next_week), a.booking_pppn
		err := rows.Scan(&f.DestinationCity, &f.Price, &f.AccommodationPppn /* etc... */)
		if err != nil {
			return nil, err
		}
		results = append(results, f)
	}

	return results, rows.Err()
}

// -------------------------------------------------------------------
// 8) A Simple main() Demo (using an in-memory SQLite for brevity)
// -------------------------------------------------------------------

func main() {
	// Example usage:
	// You'd typically have a real DB connection with your flight data loaded
	db, err := sql.Open("sqlite3", "../../data/compiled/main.db")
	if err != nil {
		log.Fatal("Failed to open DB:", err)
	}
	defer db.Close()

	// For demonstration: your flight/accommodation tables would be created & loaded with data
	// ...
	// Skipping that step here.

	// Suppose the user picks these origins and constraints in your UI:
	origins := []string{"BER", "GLA"}
	operators := []string{"OR"} // means "NYC < X AND LAX < Y"
	maxFlightPrices := []float64{300, 600}
	maxAccommodation := 200.0
	sortOption := "cheapest_hotel"

	flights, err := QueryFlights(db, origins, operators, maxFlightPrices, maxAccommodation, sortOption)
	if err != nil {
		log.Fatal("Query error:", err)
	}

	// Print out the resulting flights
	for i, f := range flights {
		fmt.Printf("%d) Destination: %s, FlightPrice: %.2f, HotelPppn: %.2f\n",
			i, f.DestinationCity, f.Price, f.AccommodationPppn)
	}
}
